//---------------------------Envelopes--------------------------
//This .dic file is probably one of the simplest you will have to edit, and in fact, if the way it works doesn't appeal to you, you can completely ignore it if you like!
//Basically, what this file does is set up some things that, for the purposes of this file, I'll call envelopes (this is what they're referred to as on the CROW-SSP Dictionary site... at least, that's what I remember, it's been a while since I've checked it). They are technically functions and can do many things, but this file is mostly an organizational tool for storing lists you may use.
//For the purposes of this file, an envelope is a list that you can populate with items, and this list can be called later during dialogue with the %(name) format. If you've read the walkthrough or gone through any of the other .dic files, you've probably seen these before. %(username) is one, which displays the user's name, and %(heshe) is another, which displays the right pronoun depending on what the user selected in bootend.dic or menu.dic. Other ones include %(passmin), which shows how many minutes have passed since the ghost was started, %(screenheight) which shows the height of the display they're currently on, and %(keroname) for the name of the second character, among many, many others. Many of these are predefined by the AYA scripting and will be listed on the CROW-SSP site mentioned above, and many of them you will never have to use.

//So where does this file come in? Well, you can define your own envelopes/variables if you want! Here's an example.

exampleenvelope
{
	"Example Envelope Dialogue 1"
	"Example Envelope Dialogue 2"
	"Example Envelope Dialogue 3"
}

//As you can see, we stated a word, opened some brackets, wrote some text, and closed the brackets. Now when you write ghost dialogue, you can write %(exampleenvelope) and your ghost will randomly display any of the three bits of text within the brackets! You can go ahead and test this yourself to see how it works, and I'll include some sample dialogue with this in aitalk.dic.

//What can you use this kind of envelope for? You can store tons of random information to keep your ghost's dialogue varied! You can store various cities you like in %(city), musicians you like in %(musicians), places your ghost has been in %(places), food you like in %(food), movies you like in %(movie), fandoms you like in %(fandom), characters you like in %(fandomcharacter), celebrities you like under %(celebrity) or friends of yours in %(friends) or bnfs in %(bnfs), folders on your computer under %(folders), Pokemon you like under %(pokemon), insults under %(insult), swear words under %(swearword) which could potentially be hilarious, just about anything! You can make lists of absolutely anything to use with dialogue for your ghost! This .dic file is only limited by your imagination!
//Not only that, but you can put an envelope IN an envelope. Here's another example.

internalenvelope
{
	"Internal Envelope Dialogue 1 - %(exampleenvelope)"
	"%(username)'s computer"
	"Here is a blanklist object - %(blanklist)."
}

//You can nest envelopes all day long, although it might get kind of convoluted if you don't keep track. This is particularly handy with %(username), so your ghost can be specific if they're talking about something of the user's, like their files or folders for example. I'll leave a few lists in here you can fill out as you like. And if this doesn't give you ideas, you can ignore this file, since nothing in it will show up unless you write it into the dialogue. You can add or take away as many items as you want from each list.

		//*********************Advanced User Info*******************************
	  //These text boxes are meant for those who have an interest in expanding or using more complicated functions in their ghost. Also for my own reference in the future since I plan on using this template too, haha. If you have no interest in any of this and just want to keep things as simple as possible, feel free to skip these boxes.
	  
	  //Because these are basically their own functions, you can do other things with them as well as display dialogue. You can add if/else checks, run other functions, have pools of alternate dialogue... the possibilities are really endless.
	  
	  //One particularly useful thing you can do is add value changes to an envelope, if your dialogue is in a place where it's not easy to add the change directly. For example...
	  
	  //FeelingsGoUp
	  //{
	  //Feelings += 1
	  //"Thank you, %(username), that was really nice of you.\e"
	  //}
	  
	  //So this would display the dialogue as well as change the value. Then you can call this in dialogue if you need to to change the value without having to do a bunch of fiddly business. Specifically I'm thinking about things like RandomTalk, where it can be finicky to have dialogue that also changes a value like this. Like "Oh... wow... %(FeelingsGoUp\e" could go into RandomTalk and still change the value effectively without breaking anything. You can of course also change multiple values at once, and if you don't put dialogue in there, it will change the value invisibly.
	  
	  //Another use for these envelopes is to shortcut certain long lines of SakuraScript you don't want to have to keep typing. A good example is if you want to change the font for a character. Take Papyrus from my Gaster ghost, he talks in the font Papyrus. But I don't want to have to type the tag for it for every line of dialogue he does. So instead I can put it in an envelope.
	  
	  //p
	//	{
	//	"\f[name,Papyrus UT]\f[height,16]"
	//	}
		
		//And then I can make one that'll change the font back to normal.
		
	//	d
	//{
	//"\f[name,default]\f[height,default]"
	//}
	
	//So in dialogue, to change fonts I'd just have to go "%(p)HEY THERE!%(d)" to change fonts back and forth quickly. These kind of shortcuts can be very useful.
	
	//Another way to use envelopes is to store multiple poses for SurfaceRestore in aitalk.dic. Gaster for example has several neutral idle poses, but also several poses for when he's scared. So I can make an envelope like
	
	//scared
	//{
	//"\0\s[9]\i[3]\i[104]\i[39]"
	//"\0\s[100]\i[2]\i[40]\i[104]"
	//"\0\s[100]\i[2]\i[40]\i[106]"
	//}
	
	//And have him randomly pick one whenever I use %(scared) in dialogue. This can be an easy way to vary certain poses without having to manually put them in one at a time, and have some variety when your ghost goes back to its neutral pose in SurfaceRestore.
		
	  //***********************************************************************

Happy
{
	narrFeelings += 5
	"\0\s[0]"
}

Sad
{
	narrFeelings -= 5
	"\0\s[0]"
}

envelope
{
	"I highly recommend you %(hobbies)."
	"Perhaps you should %(hobbies)."
}

opinions
{
	"strange"
	"fascinating"
	"interesting"
	"intriguing"
	"nice"
	"creepy"
	"odd"
	"heartwarming"
	"exciting"
}

boredsuggest
{
	"The Narrator suggested that %(nomPro) %(hobbiez)."
	"Perhaps %(nomPro) should %(hobbiez)."
}

compliments
{
	"absolutely splendid"
	"wonderful"
	"beautiful"
	"phenomenal"
	"amazing"
	"fascinating"
	"excellent"
	"astounding"
	"marvellous"
	"top-notch"
	"brilliant"
	"stupendous"
	"nice"
}

cheapcompliments
{
	"My heavens! I've never met someone who can consume as much uranium in a single sitting as you can! Just look at you go!"

	"Of all people I know who are using this exact ghost at this exact moment, your performance is easily in the top 5,000! Top 4,700 even!\w8 I won't go as far as 4,600..."
}

insult1
{
"artless"
"bawdy"
"beslubbering"
"bootless"
"churlish"
"cockered"
"clouted"
"craven"
"currish"
"dankish"
"dissembling"
"droning"
"errant"
"fawning"
"fobbing"
"froward"
"frothy"
"gleeking"
"goatish"
"gorbellied"
"impertinent"
"infectious"
"jarring"
"joggerheaded"
"lumpish"
"mammering"
"mangled"
"mewling"
"paunchy"
"pribbling"
"puking"
"puny"
"rank"
"reeky"
"roguish"
"ruftish"
"saucy"
"spleeny"
"spongy"
"surly"
"tottering"
"unmuzzled"
"vain"
"venomed"
"villainous"
"warped"
"wayward"
"weedy"
"yeasty"
}

insult2
{
"base-court"
"bat-forling"
"beef-witted"
"beetle-headed"
"boil-brained"
"clapper-clawed"
"clay-brained"
"common-kissing"
"crook-pated"
"dismal-dreaming"
"dizzy-eyed"
"doghearted"
"dread-bolted"
"earth-vexing"
"elf-skinned"
"fat-kidneyed"
"fen-sucked"
"flap-mothed"
"fly-bitten"
"folly-fallen"
"fool-born"
"fill-gorged"
"guts-griping"
"half-faced"
"hasty-witted"
"hedge-born"
"hell-hated"
"idle-headed"
"ill-breeding"
"ill-nurtured"
"knotty-pated"
"milk-livered"
"motley-minded"
"onion-eyed"
"plume-plucked"
"pottle-deep"
"pox-marked"
"reeling-ripe"
"rough-hewn"
"rude-growing"
"rump-faced"
"shard-borne"
"sheep-biting"
"spur-galled"
"swag-bellied"
"tardy-gaited"
"tickle-brained"
"toad-spotted"
"unchin-snoted"
"weather-bitten"
}

insult3
{
"apple-john"
"baggage"
"barnacle"
"bladder"
"boar-pig"
"bugbear"
"bum-bailey"
"canket-blossom"
"clack-dish"
"clotpole"
"coxcomb"
"codpiece"
"death-token"
"dewberry"
"flap-dragon"
"flax-wench"
"flirt-gill"
"foot-licker"
"futilarrian"
"giglet"
"gudgeon"
"haggard"
"harpy"
"hedge-pig"
"horn-beast"
"hugger-mugger"
"joithead"
"lewduster"
"lout"
"maggot-pie"
"malt-worm"
"mammet"
"measle"
"minnow"
"miscreant"
"moldwarp"
"mumble-news"
"nut-hook"
"pigeon-egg"
"pignut"
"puttock"
"pumbion"
"ratsbane"
"scut"
"skainsmate"
"strumpot"
"varlot"
"vassal"
"wheyface"
"wagtail"
}

books
{
	"Dirk Gently's Holistic Detective Agency"
	"The Hitchhiker's Guide to the Galaxy"
	"A Brief History of Time"
	"Alice's Adventures in Wonderland"
	"the entire Discworld series"
}

themes
{
	"nature"
	"abstract"
	"The Stanley Parable"
	"fandom"
	"space"
}

hobbies
{
	"take a break"
	"have a snack"
	"drink some water"
	"cook something"
	"watch a %(genre) movie"
	"catch up on your favourite TV show"
	"play a game"
	"play a game called The Stanley Parable"
	"read a book"
	"practice drawing"
	"do something productive for once"
	"work on one of your many projects"
	"spend time with a friend"
	"check the news"
	"check your email"
	"browse the internet"
	"learn something new"
	"organize your collection"
	"stretch your legs a little"
	"go outside"
	"go outside for 5-10 years"
}

internetoddities
{
	"[I found some intriguing fan art of us on Tumblr...]"
	"[Check out these cool videos! They were made with some program called Gacha Life...]"
	"[Look at this interesting account on Twitter... Hey why is it talking about-]"
	"[Cool playlist-]"
	"[I found this site called Archive of our Own-]"
}

genre
{
	"comedy"
	"drama"
	"documentary"
	"horror"
	"romance"
	"action"
	"crime"
	"thriller"
	"science fiction"
	"western"
	"experimental"
}

hobbies2
{
	"have a snack"
	"cook something"
	"watch a %(genre) movie"
	"catch up on your favourite TV show"
	"play a game"
	"play a game called The Stanley Parable"
	"read a book"
	"practice drawing"
	"drink some water"
	"spend time with a friend"
	"check the news"
	"check your email"
	"browse the internet"
	"learn something new"
	"organize your collection"
	"stretch your legs a little"
	"go outside"
	"go outside for 5-10 years"
}

hobbiez
{
	"have a snack"
	"cook something"
	"watch a %(genre) movie"
	"catch up on %(posPro) favourite TV show"
	"play a game"
	"play a game called The Stanley Parable"
	"read a book"
	"practice drawing"
	"drink some water"
	"spend time with a friend"
	"check the news"
	"check %(posPro) email"
	"browse the internet"
	"learn something new"
	"organize %(posPro) collection"
	"stretch %(posPro) legs a little"
	"go outside"
	"go outside for 5-10 years"
}

flavours
{
	"banana"
	"apple"
	"Rocky Road"
	"vanilla"
	"chocolate"
	"strawberry"
	"orange"
	"lemon"
	"plum"
	"rose"
	"tomato"
}

comfort
{
	"You can do it!"
	"I'm proud of you."
	"Go get 'em!"
	"You're already lovely as you are! I'm not saying you shouldn't want to change. I'm saying you shouldn't be forced to!"
	"Things will probably get better. Probably."
	"Take care of yourself. Someone out there really cares about you."
	"It'll be alright."
	"Well, even though you can't exactly reset in the real world if something goes wrong, alas, I think everything will work out in the end."
	"You are loved."
	"\_a[https://www.tumblr.com/give-soup-please/685699074236809216/holy-shit-guys-i-commissioned-kevan-brighting-to]A Gift!\_a Go ahead and download this to your computer. \_a[https://xtendedview.com/how-to/download-songs-audio-from-tumblr/5585/]Here's how.\_a"
}
//This envelope in particular I think is fun. You can use this in dialogue to pretend like your ghost is looking through your user's files!

usersfolder
{
	"Recycle Bin"
	"Documents folder"
	"Downloads folder"
	"secret folder"
	"Games folder"
	"Music folder"
	"Pictures folder"
	"Videos folder"
}

usernamesfolder
{
	"%(username)'s Recycle Bin"
	"%(username)'s Documents folder"
	"%(username)'s Downloads folder"
	"%(username)'s secret folder"
	"%(username)'s Games folder"
	"%(username)'s Music folder"
	"%(username)'s Pictures folder"
	"%(username)'s Videos folder"
}


//Now, this next envelope is unique. I've called it a double envelope at times, but this is actually technically an array. Note that it has a word, a comma, then another word. This is essentially a list being stored in this envelope. You can call one of the values by using brackets around the number of the list entry. So, the first value (the Korean word) would be %(lessonkor[0]) since all arrays start at 0. The second value (the definition) would be %(lessonkor[1]). If you have a longer array, like "word,word,word,word,word", you can keep calling values by changing the numbers, like %(lessonkor[5]) or %(lessonkor[10]). Arrays can be very powerful and useful for storing a lot of information in a condensed space, but I must level with you, I'm not very good at arrays or figuring out how to use them. :B They can be VERY useful though, if you can wrap your head around how they work. An example of pulling information from this array can be seen in aitalk.dic.

lessonfre
{
	"pomme,apple"
	"travail,labor"
	"doigt,finger"
	"parfum,perfume"
	"jeu,game"
}

lessonkor
{
	"사과(sa-gua),apple"
	"노동(no-dong),labor"
	"손가락(son-ga-rak),finger"
	"마르크스(ma-r-k-s),Marx"
	"자본주의(ja-bon-ju-yi),capitalism"
}

//Written by Zichqec https://zichqec.github.io/s-the-skeleton/

//To call the function, you can either call the function in your code like this:
//Mock("some text")
//Or in dialogue like this:
//"%(Mock('some text'))"

//Note that by default, it will produce a 'perfect' mock case, meaning that it will change between lower and uppercase every character. If you want a 'random' mock case (which is really just randomcase, but some people say mock case is better with some chaos), put a 1 as the second argument. That'd look like this: "%(Mock('some text',1))"

//If you want to write an apostrophe in dialogue, write ## and it'll be replaced with an apostrophe

Mock
{
	_argv[0] = REPLACE(_argv[0],"##","'") //Replaces ## with an apostrophe, change it if you like
    _output = ""
    if TOINT(_argv[1]) == 1 //Random mock case
    {
        for _i = 0; _i < STRLEN(_argv[0]); _i++
        {
            _let = SUBSTR(_argv[0],_i,1)
            if RAND(2) == 1
            {
                _output += TOLOWER(_let)
            }
            else
            {
                _output += TOUPPER(_let)
            }
        }
    }
    else //Perfect mock case
    {
        for _i = 0; _i < STRLEN(_argv[0]); _i++
        {
            _let = SUBSTR(_argv[0],_i,1)
			if _let == " "
			{
				_output += _let
				continue
			}
            if _m % 2 == 0
            {
                _output += TOLOWER(_let)
            }
            else
            {
                _output += TOUPPER(_let)
            }
			_m++
        }
    }
    _output
}

//Written by Zichqec https://zichqec.github.io/s-the-skeleton/

//If this all looks scary to you, no worries! All you need to do is set a few options in OnStartWordSearch, set up dialogue in WordSearchDialogue, and then add your own pool of words for it to choose from in WordSearchWords. If it gives you any trouble, let me know!

//Use this to start a new word search game: "\![*]\q[Word Search,OnStartWordSearch]"
OnStartWordSearch
{
	_rightadjust = 0 //Don't touch these ones
	_highlightcolor = ""

	//---Options. Feel free to set these however you like.---

	//_defaultballoon: Set this to the name of your balloon, as seen in the right click menu. This lets you adjust the color and positioning specifically to your balloon, without breaking it completely for other balloons!
	//_debug: Hides all letters that are not a part of words, so you can test and see how well your words are being distributed
	//_gridsize: The dimensions of your word search. I created this based on a 10x10 grid, but you can play around with it if you like.
	//_fontsize: Font size of the grid. Adjust to your liking. The bigger the better, this game can be hard on the eyes.
	//_maxwords: How many words it will attempt to add to the grid. Note: Sometimes adding a word fails, so you may end up with less words!
	//_attempts_to_place: How many times it will attempt to add a single word to the grid. If you put this higher you'll probably end up with the max amount of words in the puzzle more often, but it may impact performance.
	//_rightadjust: You can use this to center the word search in your balloon (this is in pixels). Since people can use whatever balloon they want, though, I put a check to check if they're in your default balloon. Make sure to put your balloon's name there. Note: Only works in YAYA, you might need a different setup using OnBalloonChange if you're using AYA.
	//_backwardsallowed:  1 if you want words to be able to appear backwards, 0 if you don't.
	//_highlightinverted: Words that are found are highlighted using your balloon's anchor color. If you would prefer for everything to be the anchor color, and for found words to be the color of menu choices, you can set that here.
	//_highlightcolor: Color you want for highlighting, as an R,G,B value. If you want the default color used by your balloon, put "default.anchor" instead.

	//Note: If you want to change the anchor color that's used in the grid, you can do so by adding a \f[anchorcolor,(R),(G),(B)] tag in the part of the Word Search code that displays the grid. You can also use similar tags to change the color of \__q tags, I believe. Ukadoc will have more info.

	_defaultballoon = "Twinkling Galaxy Hues"
	_debug = 0
	_gridsize = 10
	_fontsize = 15
	_maxwords = 10
	_attempts_to_place = 15
	if SHIORI3FW.BalloonName == _defaultballoon; _rightadjust = 0
	_backwardsallowed = 0
	_highlightinverted = 0
	if SHIORI3FW.BalloonName == _defaultballoon; _highlightcolor = "255,255,255"
	else; _highlightcolor = "default.anchor"

	//Don't touch these
	WSOpts = (_fontsize,_rightadjust,_highlightinverted,_highlightcolor)
	CreateWordSearch(_debug,_gridsize,_maxwords,_attempts_to_place,_backwardsallowed)
	WordsLeft = WordList
	OnWordSearch
}



//All your dialogue goes here. Don't add \e to the end of any of these.
WordSearchDialogue
{
	if _argv[0] == "Menu During Play" //Menu option at the bottom while the game is being played, such as a button to give up/quit
	{
		"\n\![*]\q[Give up,OnWordSearchQuit]\e"
	}
	elseif _argv[0] == "Invalid Word" //If the user puts in a word that isn't on the word list or was already guessed - _argv[1] is the word the user guessed
	{
		"%(_argv[1])? What kind of word is that? Whatever it is, it's not valid."
	}
	elseif _argv[0] == "Invalid Move" //If the user tried an illegal diagonal move
	{
		"You can't move like that, %(username).\w8\w8 Moves have to be completely straight lines;\w4 up,\w4 down,\w4 left,\w4 right,\w4 or diagonal."
	}
	elseif _argv[0] == "Found Word" //If the user found a word - _argv[1] is the word that was found
	{
		"You found the word %(_argv[1]). A %(compliments) word."
	}
	elseif _argv[0] == "Finished Puzzle" //If the user completed the puzzle - _argv[1] is the last word the user found. Might be a good idea to add menu buttons here.
	{
		"%(_argv[1]) was the last word!\w8\s[6] Good job, you did it!"
		--
		"\_q\n\![*]\q[Play again,OnStartWordSearch]  \![*]\q[Play something else,BACKTOMENU]\n\![*]\q[I'm done,cancelnodialogue]\e"

		narrFeelings += 5
		narrMood += 5
		ERASEVAR("WordSearch")
		ERASEVAR("WordList")
		ERASEVAR("WordsLeft")
		ERASEVAR("SearchHighlight")
		ERASEVAR("WSOpts")
	}
}

//Words you want to be placed in the puzzle go here. Be mindful of how long your words are! Make sure they're not too long to fit the grid. Probably don't make them too short, either. I'd recommend at least 4 letters. And have plenty of words available, the more the better! This has to be an array, so if you're using my other games, you won't be able to share a word pool between them. (Unless you get clever and have those word pools read from here using something like ANY(WordSearchWords)
WordSearchWords : array
{
	"Stanley"
	"Narrator"
	"Parable"
	"Adventure"
	"Line"
	"Bucket"
	"Story"
	"Choice"
	"Code"
	"Ending"
	"Freedom"
	"Countdown"
	"Door"
	"Curator"
	"Memory"
	"Zone"
	"Dork"
	"Boss"
	"Control"
	"Office"
	"Jump"
	"Crow"
	"Cafe"
	"Mind"
	"Davey"
	"Eight"
	"Shark"
	"Fern"
}

OnWordSearch
{
	_highlightarray = SearchHighlight
	_endRow = ""
	_endCol = ""
	_startRow = ""
	_startCol = ""
	_RowDist = ""
	_ColDist = ""

	//Sets up some variables for the X and Y values, and also sets up variables to check that the user doesn't make an illegal diagonal move
	if reference0 == "StartLetter"
	{
		_startRow = TOINT(reference1)
		_startCol = TOINT(reference2)
	}
	elseif reference0 == "EndLetter"
	{
		_endRow = TOINT(reference1)
		_endCol = TOINT(reference2)
		_startRow = TOINT(reference3)
		_startCol = TOINT(reference4)

		//These bits change the numbers to not be negatives, so they can be compared properly
		_RowDist = _startRow - _endRow
		if _RowDist < 0; _RowDist = -_RowDist

		_ColDist = _startCol - _endCol
		if _ColDist < 0; _ColDist = -_ColDist
	}

	_valid = 0
	_direction = ""
	_guessedword = ""
	_start = ""
	_end = ""
	//If the user attempted a guess
	if reference0 == "EndLetter"
	{
		if _startRow == _endRow //If this is a valid move (Horizontal)
		{
			_valid = 1
			if _startCol > _endCol; {_direction = "Left"; _start = _endCol; _end = _startCol}
			else; {_direction = "Right"; _start = _startCol; _end = _endCol}

			for _i = _start; _i <= _end; _i++
			{
				_guessedword += WordSearch[_startRow][_i]
			}

			if _direction == "Left"
			{
				_guessedword = WSReverse(_guessedword)
			}

			//Highlighting
			for _i = 0; _i < STRLEN(_guessedword); _i++
			{
				_row = _highlightarray[_startRow]
				_row[_start + _i] = "1"
				_highlightarray[_startRow] = _row
			}
		}
		elseif _startCol == _endCol //Vertical
		{
			_valid = 1
			if _startRow > _endRow; {_direction = "Up"; _start = _endRow; _end = _startRow}
			else; {_direction = "Down"; _start = _startRow; _end = _endRow}

			for _i = _start; _i <= _end; _i++
			{
				_guessedword += WordSearch[_i][_startCol]
			}

			if _direction == "Up"
			{
				_guessedword = WSReverse(_guessedword)
			}

			//Highlighting
			for _i = 0; _i < STRLEN(_guessedword); _i++
			{
				_row = _highlightarray[_start + _i]
				_row[_startCol] = "1"
				_highlightarray[_start + _i] = _row
			}
		}
		elseif _RowDist == _ColDist //Diagonal, if it's valid
		{
			_valid = 1

			if _startCol > _endCol && _startRow > _endRow //Going left and up
			{
				_direction = "Left Up"
				_ii = _startCol
				for _i = _startRow; _i >= _endRow; _i--
				{
					_guessedword += WordSearch[_i][_ii]

					//Highlighting
					_row = _highlightarray[_i]
					_row[_ii] = "1"
					_highlightarray[_i] = _row

					_ii--
				}
			}
			elseif _startCol > _endCol && _startRow < _endRow //going left and down
			{
				_direction = "Left Down"

				_ii = _startCol
				for _i = _startRow; _i <= _endRow; _i++
				{
					_guessedword += WordSearch[_i][_ii]

					//Highlighting
					_row = _highlightarray[_i]
					_row[_ii] = "1"
					_highlightarray[_i] = _row

					_ii--
				}
			}
			elseif _startCol < _endCol && _startRow > _endRow //going right and up
			{
				_direction = "Right Up"
				_ii = _startRow
				for _i = _startCol; _i <= _endCol; _i++
				{
					_guessedword += WordSearch[_ii][_i]

					//Highlighting
					_row = _highlightarray[_ii]
					_row[_i] = "1"
					_highlightarray[_ii] = _row

					_ii--
				}
			}
			else //going right and down
			{
				_direction = "Right Down"

				_ii = _startCol
				for _i = _startRow; _i <= _endRow; _i++
				{
					_guessedword += WordSearch[_i][_ii]

					//Highlighting
					_row = _highlightarray[_i]
					_row[_ii] = "1"
					_highlightarray[_i] = _row

					_ii++
				}
			}
		}
		else //If it's an invalid move
		{
			_valid = 0
		}


	}

	//If the word is in the list of words to find, mark it, and also remove the word from the list of words that still need to be found
	_find = ASEARCH(_guessedword,WordsLeft)
	if _find != -1
	{
		_valid = 2
		WordsLeft[_find] = IARRAY
	}

	if _valid == 2; SearchHighlight = _highlightarray
	else; _highlightarray = SearchHighlight

	//Set up the display of the grid
	_fheight = 10
	if WSOpts[0] > 0; _fheight = WSOpts[0]

	_rightadjust = 0
	if WSOpts[1] > 0; _rightadjust = WSOpts[1]

	_inverthighlight = 0
	if WSOpts[2] == 1; _inverthighlight = WSOpts[2]


	//_display = "\f[anchorfontcolor,%(WSOpts[3])]\f[height,%(_fheight)]\f[bold,1]"
	_display = "\f[anchorcolor,101,235,253,%(WSOpts[3])]\f[height,%(_fheight)]\f[bold,1]"
	if reference0 == "Win"; _display += "\f[anchorstyle,none]\f[cursorstyle,none]"
	for _i = 0; _i < ARRAYSIZE(WordSearch); _i++
	{
		_display += "\_l[%(_rightadjust)]"
		_row = WordSearch[_i]
		for _ii = 0; _ii < ARRAYSIZE(_row); _ii++
		{

			_col = _row[_ii]
			if reference0 == "Win" //If the user already won, don't display with clickable buttons
			{


				_tag1 = ""
				_tag2 = ""
				if _highlightarray[_i][_ii] == "1";
				{
					if _inverthighlight == 1
					{
						_tag1 = "\__q[OnBlank]"
						_tag2 = "\__q"
					}
					else
					{
						_tag1 = "\_a[OnBlank]"
						_tag2 = "\_a"
					}
				}
				elseif _inverthighlight == 1 //if this is a random letter but inverted highlighting is on
				{
					_tag1 = "\_a[OnBlank]"
					_tag2 = "\_a"
				}
				_display += "%(_tag1)%(_col)%(_tag2) "
			}
			else
			{
				//IF the user has selected a letter, give it a unique link and highlight it
				if reference0 == "StartLetter" && _i == _startRow && _ii == _startCol
				{
					_tag = "\_a"; if _inverthighlight == 1; _tag = "\__q"
					_display += "%(_tag)[OnWordSearch,CancelStart,%(_i),%(_ii),%(_startRow),%(_startCol)]%(_col)%(_tag) "
				}
				else //Normal display with clickable buttons
				{
					_ref = ""
					if reference0 == "StartLetter"; _ref = "EndLetter"
					else; _ref = "StartLetter"
					_tag = ""
					if _inverthighlight == 1
					{
						_tag = "\_a"
						if _highlightarray[_i][_ii] == "1"; _tag = "\__q"
					}
					else
					{
						_tag = "\__q"
						if _highlightarray[_i][_ii] == "1"; _tag = "\_a"
					}

					_display += "%(_tag)[OnWordSearch,%(_ref),%(_i),%(_ii),%(_startRow),%(_startCol)]%(_col)%(_tag) "

				}
			}
		}
		_display += "\n"
	}
	//Display word list
	_display += "\n[half]\f[height,default]\f[cursorstyle,default]"
	foreach WordList; _word
	{
		_exist = ASEARCH(_word,WordsLeft)
		if _exist == -1; _display += "\f[strike,1]" //Strike it out if it's been found already
		_display += "%(_word)"
		if _exist == -1; _display += "\f[strike,0]"
		_display += "  "
	}
	if ARRAYSIZE(WordsLeft) == 0 && reference0 != "Win"; "\![raise,OnWordSearch,Win,%(_guessedword)]\e" //If the user won, restart this function so that it can remake the board
	--
	//Dialogues for when you've made a turn. I ended up making a separate function for this because wow this function got long
	if reference0 == "EndLetter"
	{
		_display += "\n\_q\f[default]"
		if _valid == 2 //If the user found a word
		{
			_display += "%(WordSearchDialogue('Found Word',_guessedword))"
		}
		elseif _valid == 1 //If the user found a word, but it's not in the word list or has already been guessed
		{
			_display += "%(WordSearchDialogue('Invalid Word',_guessedword))"
		}
		else //If the user made an invalid move
		{
			_display += "%(WordSearchDialogue('Invalid Move'))"
		}
	}
	elseif reference0 == "Win" //If the user won
	{
		_display += "\n\_q\f[default]%(WordSearchDialogue('Finished Puzzle',reference1))"
	}
	if reference0 != "Win"; _display += "\n\f[default]%(WordSearchDialogue('Menu During Play'))"
	"\b2\f[name,Courier New]\![set,autoscroll,disable]\_q%(_display)\*\e" //Actual display
}

WSReverse //Reverses the string it's given, for the purposes of placing some words backwards
{
	_output = ""
	for _i = 0; _i < STRLEN(_argv[0]); _i++
	{
		_output = SUBSTR(_argv[0],_i,1) + _output
	}
	_output
}

CreateWordSearch //:deargodhelpme:
{
	_dimensions = 10 //Width and height of the grid
	if _argv[1] > 0; _dimensions = _argv[1]

	_totalwords = 10 //How many words to attempt to add, total (each word will be tried multiple times if it does not fit)
	if _argv[2] > 0; _totalwords = _argv[2]

	_wordtries = 15 //How many times it will attempt to place a word before giving up
	if _argv[3] > 0; _wordtries = _argv[3]

	_allowreverse = 1
	if _argv[4] == 0; _allowreverse = 0

	WordList = IARRAY
	//Create a grid of .s
	WordSearch = IARRAY

	//Setting up the base grid, and the array for highlighting words
	SearchHighlight = IARRAY
	for _i = 0; _i < _dimensions; _i++ //Rows
	{
		_highlight = ""
		_columns = ""
		for _ii = 0; _ii < _dimensions; _ii++ //Columns
		{
			if _ii != 0; {_columns += ","; _highlight += ","}
			_columns += "."
			_highlight += "0"
		}
		WordSearch ,= _columns
		SearchHighlight ,= _highlight
	}

	//Get words and add them to the grid
	_availwords = WordSearchWords
	_toadd = ""
	_orig = ""
	_placed = 0
	for _i = 0; _i < _totalwords; _i++
	{
		//Check to make sure there's a word to add. If there is, pick a random one, then erase it from the array. If the word is too long, skip it and start again.
		if ARRAYSIZE(_availwords) == 0; {LOGGING("Ran out of words to add");break}
		_toadd = TOUPPER(ANY(_availwords))
		LOGGING("Entered loop 1 - Start new word (%(_toadd))")
		_availwords[LSO] = IARRAY
		if STRLEN(_toadd) > _dimensions; {LOGGING("%(_toadd) too long for current grid size");continue}

		//This loop attempts to place the word several times, depending on how you have it set
		_placed = 0
		_orig = _toadd
		for _ii = 0; _ii < _wordtries && _placed == 0; _ii++
		{
			//Sets an orientation, decides if it should be reversed
			_orient = ANY("Horizontal,Vertical,Diagonal \,Diagonal /")
			if _allowreverse == 1 && RAND(2) == 1
			{
				_toadd = WSReverse(_toadd)
			}
			_len = STRLEN(_toadd)
			_x = RAND(_dimensions)
			_y = RAND(_dimensions)
			LOGGING("Entered loop 2 - Try to find a place for new word (%(_x),%(_y) orient: %(_orient), len: %(_len)")

			//Each of these attempts to place it based on the orientation
			if _orient == "Horizontal" //---Left to Right---
			{
				if (_x + _len) > _dimensions //If it's too long
				{
					LOGGING("Couldn't place %(_toadd), X: %(_x), orient: %(_orient), len: %(_len), tries so far: %(_ii)")
					continue
				}
				else //If it has enough space
				{
					_skip = 0
					_rowtochange = WordSearch[_y]
					for _iii = 0; _iii < STRLEN(_toadd); _iii++ //Check to see if any other words are in the way
					{
						LOGGING("Entered loop 3 - Attempt to add new word, see if other words block it")
						if _rowtochange[_x + _iii] == "." || _rowtochange[_x + _iii] == SUBSTR(_toadd,_iii,1) //If it's an empty space or a space that matches the current letter
						{
							_rowtochange[_x + _iii] = SUBSTR(_toadd,_iii,1)

						}
						else //If it's a taken space
						{
							_skip = 1
							LOGGING("Can't place %(_toadd), %(_rowtochange[_x + _iii]) in the way.")
							break
						}
					}

					if _skip == 1 //If it got blocked, skip and try placing in another place
					{
						_skip = 0
						continue
					}
					else //If it wasn't blocked, go ahead and add it
					{
						WordSearch[_y] = _rowtochange
						_placed = 1
					}
				}
			}
			elseif _orient == "Vertical" //---Top to Bottom---
			{
				if (_y + _len) > _dimensions //If it's too long
				{
					LOGGING("Couldn't place %(_toadd), Y: %(_y), orient: %(_orient), len: %(_len), tries so far: %(_ii)")
					continue
				}
				else //If it has enough space
				{
					_skip = 0
					//Make a temp array of this column
					_coltochange = IARRAY
					for _iii = 0; _iii < ARRAYSIZE(WordSearch[_x]); _iii++
					{
						_coltochange ,= WordSearch[_iii][_x]
					}

					for _iii = 0; _iii < STRLEN(_toadd); _iii++ //Check to see if any other words are in the way
					{
						LOGGING("Entered loop 3 - Attempt to add new word, see if other words block it")
						if _coltochange[_y + _iii] == "." || _coltochange[_y + _iii] == SUBSTR(_toadd,_iii,1) //If it's an empty space or a space that matches the current letter
						{
							LOGGING("placed %(SUBSTR(_toadd,_iii,1))")
							_coltochange[_y + _iii] = SUBSTR(_toadd,_iii,1)

						}
						else //If it's a taken space
						{
							_skip = 1
							LOGGING("Can't place %(_toadd), %(_coltochange[_y + _iii]) in the way.")
							break
						}
					}

					if _skip == 1 //If it got blocked, skip and try placing in another place
					{
						_skip = 0
						continue
					}
					else //If it wasn't blocked, go ahead and add it
					{
						//_x should be the column that needs changed... have to extract it out of every row though and then put it back.
						for _iii = 0; _iii < ARRAYSIZE(_coltochange); _iii++
						{
							_row = WordSearch[_iii]
							_row[_x] = _coltochange[_iii]
							WordSearch[_iii] = _row
						}
						//WordSearch[_x] = _coltochange
						_placed = 1
					}
				}
			}
			elseif _orient == "Diagonal \" //Diagonal top left to bottom right
			{
				if (_y + _len) > _dimensions || (_x + _len) > _dimensions //If it's too long
				{
					LOGGING("Couldn't place %(_toadd), Y: %(_y), orient: %(_orient), len: %(_len), tries so far: %(_ii)")
					continue
				}
				else //If it has enough space
				{
					_skip = 0
					//Make a temp array of this column
					_diagtochange = IARRAY
					for _iii = 0; _iii < _len; _iii++
					{
						_diagtochange ,= WordSearch[_y + _iii][_x + _iii]
					}

					for _iii = 0; _iii < STRLEN(_toadd); _iii++ //Check to see if any other words are in the way
					{
						LOGGING("Entered loop 3 - Attempt to add new word, see if other words block it")
						if _diagtochange[_iii] == "." || _diagtochange[_iii] == SUBSTR(_toadd,_iii,1) //If it's an empty space or a space that matches the current letter
						{
							LOGGING("placed %(SUBSTR(_toadd,_iii,1))")
							_diagtochange[_iii] = SUBSTR(_toadd,_iii,1)

						}
						else //If it's a taken space
						{
							_skip = 1
							LOGGING("Can't place %(_toadd), %(_diagtochange[_iii]) in the way.")
							break
						}
					}

					if _skip == 1 //If it got blocked, skip and try placing in another place
					{
						_skip = 0
						continue
					}
					else //If it wasn't blocked, go ahead and add it
					{
						//_x should be the column that needs changed... have to extract it out of every row though and then put it back.
						for _iii = 0; _iii < ARRAYSIZE(_diagtochange); _iii++
						{
							_row = WordSearch[_iii + _y]
							_row[_x + _iii] = _diagtochange[_iii]
							WordSearch[_iii + _y] = _row
						}
						_placed = 1
					}
				}
			}
			elseif _orient == "Diagonal /" //diagonal bottom left to top right
			{
				if (_y - _len) < 0 || (_x + _len) > _dimensions //If it's too long
				{
					LOGGING("Couldn't place %(_toadd), Y: %(_y), orient: %(_orient), len: %(_len), tries so far: %(_ii)")
					continue
				}
				else //If it has enough space
				{
					_skip = 0
					//Make a temp array of this column
					_diagtochange = IARRAY
					for _iii = 0; _iii < _len; _iii++
					{
						LOGGING("Diagpath %(_iii): '%(WordSearch[_y - _iii][_x + _iii])'")
						_diagtochange ,= WordSearch[_y - _iii][_x + _iii]
					}

					for _iii = 0; _iii < STRLEN(_toadd); _iii++ //Check to see if any other words are in the way
					{
						LOGGING("Entered loop 3 - Attempt to add new word, see if other words block it")
						if _diagtochange[_iii] == "." || _diagtochange[_iii] == SUBSTR(_toadd,_iii,1) //If it's an empty space or a space that matches the current letter
						{
							LOGGING("placed %(SUBSTR(_toadd,_iii,1))")
							_diagtochange[_iii] = SUBSTR(_toadd,_iii,1)

						}
						else //If it's a taken space
						{
							_skip = 1
							LOGGING("Can't place %(_toadd), %(_diagtochange[_iii]) in the way.")
							break
						}
					}

					if _skip == 1 //If it got blocked, skip and try placing in another place
					{
						_skip = 0
						continue
					}
					else //If it wasn't blocked, go ahead and add it
					{
						//_x should be the column that needs changed... have to extract it out of every row though and then put it back.
						//_c = 0
						LOGGING("To place: %(_diagtochange)")
						for _iii = 0; _iii < ARRAYSIZE(_diagtochange); _iii++
						{
							_row = WordSearch[_y - _iii]
							_row[_x + _iii] = _diagtochange[_iii]
							WordSearch[_y - _iii] = _row
							//_c++
						}
						//WordSearch[_x] = _diagtochange
						_placed = 1
					}
				}
			}
		}
		if _placed == 1; WordList ,= _orig
	}

	//Fill empty spaces on the grid
	for _i = 0; _i < ARRAYSIZE(WordSearch); _i++
	{
		_row = WordSearch[_i]
		for _ii = 0; _ii < ARRAYSIZE(_row); _ii++
		{
			//Comment this out if you want just .s so you can see the words it placed
			if _row[_ii] == "." && _argv[0] != 1; _row[_ii] = ANY("A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z")
		}
		WordSearch[_i] = _row
	}
}

//Written by Zichqec https://zichqec.github.io/s-the-skeleton/index.html

OnStartHangman //Sets up starting variables
{
	HMword = hangmanwords //Pulls the word to guess from a pool of words
	HMlet = IARRAY //HMlet[0] is guessed letters, HMlet[1] is incorrect letters
	OnHangman
}

OnHangman //Main game window
{
	_maxwrong = 8 //Maximum incorrect guesses - set to whatever you like
	_word = ""
	_left = 0
	for _i = 0; _i < STRLEN(HMword); _i++
	{
		_let = TOLOWER(SUBSTR(HMword,_i,1)) //Get the current letter and make it lowercase
		if _let _in_ HMlet[0] || _let == " "
		{
			_word += "%(SUBSTR(HMword,_i,1))"
		}
		else
		{
			_word += "_ "
			_left++
		}
	}
	--
	if (STRLEN(HMlet[1]) / 2) >= _maxwrong //If the number of incorrect letters is equal to or greater than the number of max tries
	{
		"\0\s[0]Sorry, you're all out of guesses! The word was %(HMword). I suppose you can try again?"
	}
	elseif _left > 0 //If there are still letters to guess
	{
		_mistakes = (_maxwrong - (STRLEN(HMlet[1]) / 2))
		_marker = ""

		"\0\_q\*%(bb)\![set,balloontimeout,-1]\![set,autoscroll,disable]\![open,inputbox,OnGuessNormal,-1]"
		--
		"%(_word)\n\nGuessed so far: %(HMlet[1])\n\nTries left: "
		--
		for _i = 0; _i < _mistakes; _i++
		{
			_marker += "\![*]"
		}
		--
		"%(_marker)"
		--
		if _left > 1
		{
			"\n\n\![*]\q[Guess the whole word,HangmanGuessWhole]"
		}
		--
		"\n\![*]\q[Open the input box again,HangmanInput]\n\n\![*]\q[Give up,HangmanQuit]\e"
	}
	else //If _left is still 0, the user has guessed all letters correctly
	{
		HangmanWin
		--
		"\0\s[0]You've got it! It was %(HMword)."
	}
	--
	HangmanBack
}

OnGuessNormal
{
	if TOSTR(reference0) == "0.0" || TOSTR(reference0) == "0.000000"; reference0 = "." //Unlikely to come up, but periods are handled strangely, and also differently between aya and yaya because screw you lol
	if STRLEN(reference0) > 1 //The user has put in more than 1 letter
	{
		"\0\s[0]Single letters only, please.\x"
	}
	elseif TOLOWER(reference0) _in_ TOLOWER(HMlet[0]) //The user has already guessed that letter
	{
		"\0\s[0]You already guessed %(reference0)! Try something else.\x"
	}
	elseif TOLOWER(reference0) _in_ TOLOWER(HMword) //The letter is in the word
	{
		HMlet[0] += reference0
	}
	else //The letter is not in the word
	{
		HMlet[0] += reference0
		HMlet[1] += "%(TOLOWER(reference0)) "
	}
	--
	OnHangman
}

Select.HangmanGuessWhole
{
	_word = ""
	_left = 0
	for _i = 0; _i < STRLEN(HMword); _i++
	{
		_let = TOLOWER(SUBSTR(HMword,_i,1)) //Get the current letter and make it lowercase
		if _let _in_ HMlet[0] || _let == " "
		{
			_word += "%(SUBSTR(HMword,_i,1))"
		}
		else
		{
			_word += "_ "
			_left++
		}
	}
	"\0\*%(b)\![set,balloontimeout,-1]\![set,autoscroll,disable]\![close,inputbox,OnGuessNormal]\![open,inputbox,OnGuessWhole,-1]"
	--
	"\0\s[0]Feeling reckless? Alright, the word so far is %(_word)\n\nYou've guessed these letters so far: %(HMlet[1])\n\nWhat do you think it is?"
	--
	"\n\n\n\![*]\q[Open the input box again,WholeInput]\n\n\![*]\q[Give up,HangmanQuit]\e"
}

OnGuessWhole
{
	_word = ""
	_left = 0
	for _i = 0; _i < STRLEN(HMword); _i++
	{
		_let = TOLOWER(SUBSTR(HMword,_i,1)) //Get the current letter and make it lowercase
		if _let _in_ HMlet[0] || _let == " "
		{
			_word += "%(SUBSTR(HMword,_i,1))"
		}
		else
		{
			_word += "_ "
			_left++
		}
	}
	if TOLOWER(reference0) == TOLOWER(HMword) //Correct guess, instant win
	{
		HangmanWin
		--
		"\0\s[0]\w8...Wow! That's right, it was %(HMword)! You guessed it with %(_left) letters still blank! I admit, you seem to be getting good at this."
	}
	else //Incorrect guess, instant lose
	{
		"\0\s[0]\w8...Nope, it was %(HMword)! \s[6]I win, and you lose! Haha! \w8\s[0]...Perhaps you could try again?"
	}
	--
	HangmanBack
}

Select.HangmanInput
{
	"\C\![close,inputbox,OnGuessNormal]\![open,inputbox,OnGuessNormal,-1]\_l[0,0] "
}

Select.WholeInput
{
	"\C\![close,inputbox,OnGuessWhole]\![open,inputbox,OnGuessWhole,-1]\_l[0,0] "
}

Select.HangmanQuit
{
	"\0\![close,inputbox,OnGuessNormal]\![close,inputbox,OnGuessWhole]%(b)"
	--
	"\0\s[0]You quit?!\w8 ...Oh, alright. It was %(HMword). Want to have another go?"
	--
	HangmanBack
}

HangmanBack
{
	"\n\n\![*]\q[Another!,OnStartHangman]\n\![*]\q[I'm done,OnManQuit]\e"
}

HangmanWin //This function is called every time the user wins hangman. You can use it to easily add friendship/money/whatever in one easy place. This does not include dialogue, it's just for variable changes. The ones I've left in here are examples.
{
	narrFeelings += 1
	narrMood += 1
}

hangmanwords : nonoverlap //Words it can choose - add lots of these!
{
	"Stanley"
	"Narrator"
	"Parable"
	"Adventure"
	"Line"
	"Bucket"
	"Story"
	"Choice"
	"Code"
	"Ending"
	"Freedom"
	"Countdown"
	"Door"
	"Curator"
	"Memory"
	"Zone"
	"Dork"
	"Boss"
	"Control"
	"Office"
	"Jump"
	"Crow"
	"Cafe"
	"Mind"
	"Davey"
	"Eight"
	"Shark"
	"Fern"
}

OnWordSearchQuit
{
	"\0\s[0]A quitter, eh? A pity. Have another go? Or no?"
	--
	"\_q\n\![*]\q[Play again,OnStartWordSearch]  \![*]\q[Play something else,BACKTOMENU]\n\![*]\q[I'm done,cancelnodialogue]\e"
}

//Written by Zichqec https://zichqec.github.io/s-the-skeleton/index.html

OnStartRPS
{
	"\0\s[0]One of my favourite games."
	"\0\s[0]You're on!"
	"\0\s[0]This game truly stands the test of time."
	--
	"\w8\w8 Rock,\w4 paper,\w4 scissors..."
	--
	"\_q\n\n/
	\![*]\q[Rock,OnRPS,rock,%(reference1),%(reference2),%(reference3),%(reference4)]\n/
	\![*]\q[Paper,OnRPS,paper,%(reference1),%(reference2),%(reference3),%(reference4)]\n/
	\![*]\q[Scissors,OnRPS,scissors,%(reference1),%(reference2),%(reference3),%(reference4)]\n\n/
	\![*]\q[Nevermind,OnRPSQuit]\e"
}

OnRPS
{
	//If these values are empty, set them to 0. These count the number of matches, number of wins, number of losses, and number of draws, respectively
	if reference1 == ""; reference1 = 0
	if reference2 == ""; reference2 = 0
	if reference3 == ""; reference3 = 0
	if reference4 == ""; reference4 = 0
	
	_userthrow = reference0 //Gets the user's pick
	_ghostthrow = ANY("rock,paper,scissors") //Gets the ghost's pick. ANY chooses randomly from the comma-separated list
	
	//Figures out who won
	_winlose = ""
	if _userthrow == _ghostthrow; _winlose = "tie"
	elseif _userthrow == "rock" && _ghostthrow == "scissors"; _winlose = "win"
	elseif _userthrow == "paper" && _ghostthrow == "rock"; _winlose = "win"
	elseif _userthrow == "scissors" && _ghostthrow == "paper"; _winlose = "win"
	else; _winlose = "lose"
	
	//Figures out what surface the ghost should be using. Put your surfaces in here.
	_pose = ""
	if _winlose == "lose" //If the ghost won
	{
		if _ghostthrow == "rock"; _pose = "\s[0]"
		elseif _ghostthrow == "paper"; _pose = "\s[0]"
		else; _pose = "\s[0]" //Scissors
	}
	else //If the user won or it's a tie. You can make another elseif if you want these to be different.
	{
		if _ghostthrow == "rock"; _pose = "\s[0]"
		elseif _ghostthrow == "paper"; _pose = "\s[0]"
		else; _pose = "\s[0]" //Scissors
	}
	
	//Gets the throw that won. If it's a draw, it'll default to the ghost, but that won't matter because it won't be called.
	_winthrow = _ghostthrow
	if _winlose == "win"; _winthrow = _userthrow
	
	//Phrases to add extra spice to dialogue
	_winreason = ""
	if _winthrow == "rock"; _winreason = "rock smashes scissors"
	elseif _winthrow == "paper"; _winreason = "paper covers rock"
	else; _winreason = "scissors cuts up paper"
	
	//Note - If you want to have the winreason or the throws be capitalized, you can use my capitalize function like so: %(Capitalize(_winreason))
	"\0%(_pose)" //Sets up the appropriate pose
	--
	reference1++ //Count of matches
	if _winlose == "win" //If the user won
	{
		reference2++ //Count of wins
		narrFeelings += 1
		narrMood--
		"%(_userthrow) beats %(_ghostthrow), you won! You...\w4 clearly cheated.\w7"
		"Oh,\w4\s[4] %(_winreason), I lost!\s[0]\w7"
	}
	elseif _winlose == "tie" //If it was a tie
	{
		reference4++ //Count of ties
		narrFeelings += 1
		"Heh, we both picked %(_userthrow). It's a draw.\w7"
		"Hm, we picked the same thing, it's a draw.\w7"
	}
	else //If the ghost won
	{
		reference3++ //Count of losses
		narrFeelings += 3
		narrMood += 3
		"%(_ghostthrow) beats %(_userthrow)! \s[6]I win!\w7 I'm really good at this game."
		"Got you!\w8\s[6] %(_winreason)!"
	}
	--
	"" //A pause and space between the dialogues. Remove or change if you like.
	--
	//You can use _winlose to make special comments for specific outcomes, if you want. It's 'win' if the user won, 'lose' if the ghost won, and 'tie' if it was a draw
	"\s[0]Let's play again!"
	"\s[0]Wish to have another go?"
	if _winlose == "win"; "\s[0] \w8Let's go for another round,\w4 I'll certainly beat you this time!"
	if _winlose == "lose"; "\s[8] \w8Let's do another round,\w4 I want to beat you once again!"
	if _winlose == "tie"; "\s[0] \w8Another round,\w4 please?"
	--
	"\_q\n\n/
	Matches: %(reference1)  Won: %(reference2)  Lost: %(reference3)  Ties: %(reference4)\n/
	\![*]\q[Another round!,OnStartRPS,Dummy value,%(reference1),%(reference2),%(reference3),%(reference4)]\n/
	\![*]\q[Close,OnRPSQuit]\e"
}

OnRPSQuit
{
	"\0\s[0]Quitting, hm? That's...\w5 alright. Hope you don't quit next time...\e"
}

OnJumboQuit
{
	"\0\s[0]Quitting, hm? That's...\w5 alright. Hope you don't quit next time...\e"
}

OnManQuit
{
	"\0\s[0]Quitting, hm? That's...\w5 alright. Hope you don't quit next time...\e"
}

//Written by Zichqec https://zichqec.github.io/s-the-skeleton/

//To call the function, you can either call the function in your code like this:
//Capitalize(SomeEnvelope) or Capitalize("some text")
//Or in dialogue like this:
//"%(Capitalize(SomeEnvelope))" or "%(Capitalize('some text'))"

Capitalize
{
	_buffer = SUBSTR(_argv[0],0,1) //Storing the first character in _buffer
	_argv[0] = ERASE(_argv[0],0,1) //Erasing the first character from _argv[0]
	_argv[0] = INSERT(_argv[0],0,TOUPPER(_buffer)) //Making the character in _buffer uppercase and inserting it back into _argv[0]
	_argv[0] //Returns the capitalized word
}
//Written by Zichqec https://zichqec.github.io/s-the-skeleton/

//Main game window
OnJuniorJumble
{
	_word = JumbleWords
	
	//Scramble the word
	_temp = TOLOWER(_word)
	_jumbled = ""
	while STRLEN(_temp) > 0
	{
		_rand = RAND(STRLEN(_temp))
		_jumbled += SUBSTR(_temp,_rand,1)
		_temp = ERASE(_temp,_rand,1)
	}

	"\0\*\![close,inputbox,OnJuniorJumbleGuess,-1]\![open,inputbox,OnJuniorJumbleGuess,-1,--reference=%(_word)]"
	--
	"Unscramble the word:"
	--
	"\n\n\f[height,+4]%(_jumbled)\f[default]"
	--
	"\_q\n\n\![*]\q[Give up,OnJuniorJumbleQuit,%(_word)]\e"
}

//After the user puts in a guess
OnJuniorJumbleGuess
{
	_word = reference2
	
	if reference0 == ""; "\![raise,OnJuniorJumbleQuit,%(_word)]"
	elseif TOLOWER(reference0) == TOLOWER(_word) //Win
	{
		narrFeelings += 5
		narrMood += 5
		"That's correct! The word was %(_word)."
	}
	else //Lose
	{
		//The \_? around the %(reference0) prevents the user from running any sakurascript tags here. Make sure you keep those.
		"Mm, not quite.\w8 You put in \_?%(reference0)\_?,\w4 the word was %(_word)."
	}
	--
	"\_q\n\n\![*]\q[Another word,OnJuniorJumble]\n\![*]\q[I'm done,OnJumboQuit]\e"
}

//If the user quits or puts in nothing
OnJuniorJumbleQuit
{
	_word = reference0
	
	"\![close,inputbox,OnJuniorJumbleGuess,-1]"
	--
	"Oh, OK...\w8\w8 The word was %(_word). Play again? Please?"
	--
	"\_q\n\n\![*]\q[Another word,OnJuniorJumble]\n\![*]\q[I'm done,OnJumboQuit]\e"
}

//Fill with words you want it to use - the more the better! Words themed around your ghost can be especially fun. If you also have my hangman game, you could change it so that they share the same pool of words.
//Keep in mind that anagrams are mean! Slightly longer words are probably better. You could try using one of those online scrabble helpers to check your words and see if any other words of the same length come up
JumbleWords
{
	"Freedom"
	"Countdown"
	"Adventure"
	"Stanley"
	"Bucket"
	"Ending"
	"Inspiration"
	"Exploration"
	"Ornithophobia"
	"Backgammon"
	"Obfuscation"
	"Synesthesia"
	"Systematic"
	"Submarine"
	"Synergize"
	"Opportunity"
	"Literature"
}

 //**** Don't touch this ***************************************************************
 //This is code stuff and nothing for you to worry about, just save the .dic and move on! You're done!
 
 On_\person
{
 	person
}
